# Compiler Infrastructure for HIP Metadata Generation

**Date:** 2025-11-06
**Status:** Design Complete, Ready for Implementation
**Goal:** Automatic metadata generation during kernel compilation

---

## Overview

This document describes the compiler infrastructure needed to automatically generate HIP kernel metadata during compilation. This is **Phase 2** of the metadata generation strategy.

## Current State (Phase 1 - Manual/Python)

‚úÖ **What Works:**
- Runtime has metadata marshaling implemented
- Manual metadata creation works perfectly
- Test framework validates end-to-end flow
- Python script serves as reference implementation

üîß **What's Manual:**
- Metadata must be hand-written or generated by external script
- Not integrated into build process
- Requires debug info and post-processing

## Goal (Phase 2 - Compiler Integration)

**Automatic metadata generation** during kernel compilation:

```
kernel.hip ‚Üí [Vortex Clang with HIP plugin] ‚Üí kernel.o + metadata.o
```

### Benefits
- ‚úÖ No manual metadata creation
- ‚úÖ Always accurate (derived from actual types)
- ‚úÖ Integrated into compilation
- ‚úÖ No external tools needed
- ‚úÖ Works without debug info

---

## Vortex LLVM Compiler Architecture

### Repository
**Location:** Custom LLVM fork maintained by Vortex
**URL:** https://github.com/vortexgpgpu/llvm.git
**Branch:** Vortex-specific features

### Current Compilation Flow

```
HIP Source (.hip/.cpp)
    ‚Üì
[Vortex Clang Frontend]
    ‚Üì Parse & Semantic Analysis
LLVM IR (RISC-V target)
    ‚Üì Optimization Passes
[Vortex-specific optimizations]
    ‚Üì Target-specific features (+vortex, +zicond)
RISC-V Assembly
    ‚Üì Assembler
RISC-V ELF Binary
    ‚Üì vxbin.py (external)
Vortex Binary (.vxbin)
```

### Key Components

#### 1. Clang Frontend
**Location:** `llvm-project/clang/`

- **Parser:** Handles C/C++ syntax
- **Sema:** Semantic analysis, type checking
- **AST:** Abstract Syntax Tree representation
- **CodeGen:** Converts AST to LLVM IR

#### 2. LLVM Middle-End
**Location:** `llvm-project/llvm/lib/`

- **IR:** Intermediate representation
- **Passes:** Optimization and transformation passes
- **Analysis:** Data flow, dependency analysis

#### 3. RISC-V Backend
**Location:** `llvm-project/llvm/lib/Target/RISCV/`

- **Target Machine:** RISC-V code generation
- **Instruction Selection:** Pattern matching to RISC-V instructions
- **Register Allocation:** RISC-V register assignment
- **Vortex Extensions:** Custom features (+vortex, +zicond)

---

## Where to Add Metadata Generation

### Option 1: Clang Plugin (Recommended)

**Location:** `llvm-project/clang/examples/` or `vortex-hip-plugin/`

**Advantages:**
- ‚úÖ Access to full AST with type information
- ‚úÖ Clean separation from compiler internals
- ‚úÖ Easy to maintain
- ‚úÖ Can generate separate .cpp file

**Implementation:**
```cpp
// VortexHIPPlugin.cpp
class HIPMetadataAction : public PluginASTAction {
  bool ParseArgs(const std::vector<std::string> &args) override;

  std::unique_ptr<ASTConsumer> CreateASTConsumer(
      CompilerInstance &CI, StringRef InFile) override {
    return std::make_unique<HIPMetadataConsumer>();
  }
};

class HIPMetadataConsumer : public ASTConsumer {
  void HandleTranslationUnit(ASTContext &Context) override {
    // Walk AST looking for __global__ functions
    TraverseDecl(Context.getTranslationUnitDecl());
  }

  bool VisitFunctionDecl(FunctionDecl *FD) {
    if (isHIPKernel(FD)) {
      generateMetadata(FD);
    }
  }
};
```

**Usage:**
```bash
clang++ -fplugin=libVortexHIP.so -fsyntax-only kernel.cpp
# Generates: kernel_metadata.cpp
```

### Option 2: LLVM IR Pass

**Location:** `llvm-project/llvm/lib/Transforms/VortexHIP/`

**Advantages:**
- ‚úÖ Access to LLVM IR type information
- ‚úÖ Can analyze optimized code
- ‚úÖ Integrated into pass pipeline

**Disadvantages:**
- ‚ö†Ô∏è Less type information than AST
- ‚ö†Ô∏è Harder to map back to source

**Implementation:**
```cpp
// VortexHIPMetadataPass.cpp
class HIPMetadataPass : public ModulePass {
  bool runOnModule(Module &M) override {
    for (Function &F : M) {
      if (isHIPKernel(F)) {
        auto metadata = extractArgumentMetadata(F);
        generateRegistrationCode(F, metadata);
      }
    }
    return true;
  }

  bool isHIPKernel(Function &F) {
    // Check calling convention or attributes
    return F.getCallingConv() == CallingConv::AMDGPU_KERNEL ||
           F.hasFnAttribute("hip-kernel");
  }
};
```

### Option 3: CodeGen (Backend Integration)

**Location:** `llvm-project/llvm/lib/Target/RISCV/`

**Advantages:**
- ‚úÖ Deeply integrated
- ‚úÖ Can emit metadata directly

**Disadvantages:**
- ‚ö†Ô∏è Most complex implementation
- ‚ö†Ô∏è Tightly coupled to backend
- ‚ö†Ô∏è Harder to maintain

---

## Detailed Implementation: Clang Plugin Approach

### Step 1: Kernel Detection

**Goal:** Identify HIP kernel functions

**Methods:**

1. **AST Attributes**
   ```cpp
   bool isHIPKernel(FunctionDecl *FD) {
     // Check for __global__ attribute
     if (FD->hasAttr<CUDAGlobalAttr>()) {
       return true;
     }

     // Check for __attribute__((kernel))
     for (auto *Attr : FD->attrs()) {
       if (auto *AA = dyn_cast<AnnotateAttr>(Attr)) {
         if (AA->getAnnotation() == "hip_kernel") {
           return true;
         }
       }
     }

     return false;
   }
   ```

2. **Function Naming Convention**
   ```cpp
   // Alternative: mark kernels with special naming
   bool isHIPKernel(FunctionDecl *FD) {
     return FD->getName().startswith("__hip_kernel_");
   }
   ```

### Step 2: Type Information Extraction

**Goal:** Get size, alignment, and pointer information for each argument

**Implementation:**
```cpp
struct ArgumentMetadata {
  std::string name;
  uint64_t size;
  uint64_t alignment;
  bool is_pointer;
};

std::vector<ArgumentMetadata> extractArguments(FunctionDecl *FD, ASTContext &Ctx) {
  std::vector<ArgumentMetadata> args;

  for (ParmVarDecl *Param : FD->parameters()) {
    QualType Type = Param->getType();

    ArgumentMetadata meta;
    meta.name = Param->getName().str();
    meta.size = Ctx.getTypeSize(Type) / 8;      // bits to bytes
    meta.alignment = Ctx.getTypeAlign(Type) / 8;
    meta.is_pointer = Type->isPointerType();

    args.push_back(meta);
  }

  return args;
}
```

**Type System Handling:**

```cpp
void analyzeType(QualType Type, ASTContext &Ctx, ArgumentMetadata &meta) {
  // Strip qualifiers (const, volatile)
  Type = Type.getCanonicalType();

  if (Type->isPointerType()) {
    meta.is_pointer = true;
    meta.size = Ctx.getTypeSize(Ctx.VoidPtrTy) / 8;
    meta.alignment = Ctx.getTypeAlign(Ctx.VoidPtrTy) / 8;
  }
  else if (Type->isIntegerType()) {
    meta.is_pointer = false;
    meta.size = Ctx.getTypeSize(Type) / 8;
    meta.alignment = Ctx.getTypeAlign(Type) / 8;
  }
  else if (Type->isFloatingType()) {
    meta.is_pointer = false;
    meta.size = Ctx.getTypeSize(Type) / 8;
    meta.alignment = Ctx.getTypeAlign(Type) / 8;
  }
  else if (Type->isStructureOrClassType()) {
    // Struct by value
    meta.is_pointer = false;
    const RecordType *RT = Type->getAs<RecordType>();
    const RecordDecl *RD = RT->getDecl();
    const ASTRecordLayout &Layout = Ctx.getASTRecordLayout(RD);
    meta.size = Layout.getSize().getQuantity();
    meta.alignment = Layout.getAlignment().getQuantity();
  }
  else if (Type->isArrayType()) {
    // Array (usually decays to pointer)
    const ConstantArrayType *CAT = Ctx.getAsConstantArrayType(Type);
    QualType ElementType = CAT->getElementType();
    uint64_t NumElements = CAT->getSize().getZExtValue();
    meta.size = (Ctx.getTypeSize(ElementType) / 8) * NumElements;
    meta.alignment = Ctx.getTypeAlign(ElementType) / 8;
    meta.is_pointer = false;
  }
}
```

### Step 3: Layout Calculation

**Goal:** Calculate offsets with proper alignment

```cpp
struct LayoutInfo {
  std::string name;
  uint64_t offset;
  uint64_t size;
  uint64_t alignment;
  bool is_pointer;
};

std::vector<LayoutInfo> calculateLayout(const std::vector<ArgumentMetadata> &args) {
  std::vector<LayoutInfo> layout;
  uint64_t current_offset = 0;

  for (const auto &arg : args) {
    // Calculate padding for alignment
    uint64_t padding = (arg.alignment - (current_offset % arg.alignment)) % arg.alignment;
    current_offset += padding;

    LayoutInfo info;
    info.name = arg.name;
    info.offset = current_offset;
    info.size = arg.size;
    info.alignment = arg.alignment;
    info.is_pointer = arg.is_pointer;

    layout.push_back(info);
    current_offset += arg.size;
  }

  return layout;
}
```

### Step 4: Code Generation

**Goal:** Emit C++ registration code

```cpp
void generateRegistrationCode(const std::string &kernel_name,
                               const std::vector<LayoutInfo> &layout,
                               raw_ostream &OS) {
  OS << "// Auto-generated metadata for " << kernel_name << "\n";
  OS << "#include \"vortex_hip_runtime.h\"\n";
  OS << "#include <stdio.h>\n\n";

  // Binary symbols
  OS << "extern \"C\" {\n";
  OS << "  extern const uint8_t kernel_vxbin[];\n";
  OS << "  extern const uint8_t kernel_vxbin_end[];\n";
  OS << "}\n\n";

  OS << "static const size_t kernel_vxbin_size = \n";
  OS << "  (size_t)(&kernel_vxbin_end[0]) - (size_t)(&kernel_vxbin[0]);\n\n";

  // Kernel handle
  OS << "void* " << kernel_name << "_handle = nullptr;\n\n";

  // Metadata array
  OS << "static const hipKernelArgumentMetadata " << kernel_name << "_metadata[] = {\n";
  for (const auto &arg : layout) {
    OS << "  {.offset = " << arg.offset << ", "
       << ".size = " << arg.size << ", "
       << ".alignment = " << arg.alignment << ", "
       << ".is_pointer = " << (arg.is_pointer ? 1 : 0) << "},  // " << arg.name << "\n";
  }
  OS << "};\n\n";

  // Registration function
  OS << "__attribute__((constructor))\n";
  OS << "static void register_" << kernel_name << "() {\n";
  OS << "  hipError_t err = __hipRegisterFunctionWithMetadata(\n";
  OS << "    &" << kernel_name << "_handle,\n";
  OS << "    \"" << kernel_name << "\",\n";
  OS << "    kernel_vxbin,\n";
  OS << "    kernel_vxbin_size,\n";
  OS << "    " << layout.size() << ",\n";
  OS << "    " << kernel_name << "_metadata\n";
  OS << "  );\n\n";
  OS << "  if (err != hipSuccess) {\n";
  OS << "    fprintf(stderr, \"Failed to register kernel: %s\\n\", hipGetErrorString(err));\n";
  OS << "  }\n";
  OS << "}\n";
}
```

---

## Build System Integration

### Clang Plugin Compilation

```makefile
# In Vortex LLVM build

VORTEX_HIP_PLUGIN_DIR = $(LLVM_BUILD)/tools/clang/examples/VortexHIPPlugin

VortexHIPPlugin.so: VortexHIPPlugin.cpp
	$(CXX) -shared -fPIC \
		-I$(LLVM_SRC)/clang/include \
		-I$(LLVM_BUILD)/clang/include \
		-I$(LLVM_SRC)/llvm/include \
		-I$(LLVM_BUILD)/llvm/include \
		-L$(LLVM_BUILD)/lib \
		VortexHIPPlugin.cpp -o VortexHIPPlugin.so
```

### Usage in Application Build

```makefile
# Application Makefile

kernel_metadata.cpp: kernel.cpp
	$(VORTEX_CLANG) -fplugin=$(VORTEX_HIP_PLUGIN) \
		-fsyntax-only \
		-Xclang -plugin-arg-vortex-hip -Xclang -output=kernel_metadata.cpp \
		$<

kernel.elf: kernel.cpp
	$(VORTEX_CLANG) $(VORTEX_CFLAGS) $< -o $@

app: main.o kernel_metadata.o kernel_vxbin.o
	$(CXX) $^ -lhip_vortex -o $@
```

### Integrated Driver (Future)

**Goal:** Single command builds everything

```bash
# Future: hip-clang wrapper
hip-clang++ kernel.cpp -o kernel
# Automatically:
# 1. Compiles kernel to RISC-V ELF
# 2. Generates metadata via plugin
# 3. Converts to vxbin
# 4. Links everything together
```

---

## Architecture-Specific Considerations

### RISC-V 32-bit (RV32)
- Pointers: 4 bytes, 4-byte aligned
- int: 4 bytes
- long: 4 bytes
- long long: 8 bytes
- float: 4 bytes
- double: 8 bytes

### RISC-V 64-bit (RV64)
- Pointers: 8 bytes, 8-byte aligned
- int: 4 bytes
- long: 8 bytes
- long long: 8 bytes
- float: 4 bytes
- double: 8 bytes

**Getting Target Info:**
```cpp
const TargetInfo &TI = Ctx.getTargetInfo();
unsigned PointerWidth = TI.getPointerWidth(0);  // bits
unsigned PointerAlign = TI.getPointerAlign(0);  // bits

bool isRV32 = (PointerWidth == 32);
```

---

## Testing Strategy

### Unit Tests

**Location:** `llvm-project/clang/unittests/VortexHIP/`

```cpp
TEST(VortexHIPMetadata, SimpleKernel) {
  // Test: float* a, float* b, float* c, int n
  // Expected: 4 args, pointers are 4/8 bytes depending on arch
}

TEST(VortexHIPMetadata, MixedTypes) {
  // Test: int a, float* b, double c, char* d
  // Expected: correct sizes and alignments
}

TEST(VortexHIPMetadata, StructByValue) {
  // Test: struct Vec3 { float x, y, z; }
  // Expected: 12-byte struct, 4-byte aligned
}
```

### Integration Tests

**Location:** `vortex_hip/tests/compiler/`

```bash
# Test 1: Simple kernel
clang++ -fplugin=VortexHIP.so kernel_simple.cpp
diff kernel_simple_metadata.cpp expected_metadata.cpp

# Test 2: Complex types
clang++ -fplugin=VortexHIP.so kernel_complex.cpp
./test_complex  # Verify marshaling works
```

---

## Implementation Phases

### Phase 2a: Basic Plugin (Week 1-2)
- ‚úÖ Detect __global__ functions
- ‚úÖ Extract basic types (int, float, pointers)
- ‚úÖ Generate metadata array
- ‚úÖ Test with simple kernels

### Phase 2b: Type System (Week 3-4)
- ‚úÖ Struct by value
- ‚úÖ Arrays
- ‚úÖ Typedefs
- ‚úÖ Const/volatile qualifiers
- ‚úÖ Architecture-specific sizes

### Phase 2c: Integration (Week 5-6)
- ‚úÖ Build system integration
- ‚úÖ Driver wrapper (hip-clang++)
- ‚úÖ CMake support
- ‚úÖ Documentation

### Phase 2d: Production (Week 7+)
- ‚úÖ Error handling
- ‚úÖ Edge cases
- ‚úÖ Performance optimization
- ‚úÖ Comprehensive tests

---

## File Locations Summary

### Source Files to Create

```
llvm-project/clang/examples/VortexHIPPlugin/
‚îú‚îÄ‚îÄ VortexHIPPlugin.cpp          # Main plugin implementation
‚îú‚îÄ‚îÄ MetadataGenerator.h          # Metadata generation logic
‚îú‚îÄ‚îÄ MetadataGenerator.cpp
‚îú‚îÄ‚îÄ CMakeLists.txt               # Build configuration
‚îî‚îÄ‚îÄ README.md                    # Plugin documentation

vortex_hip/compiler/
‚îú‚îÄ‚îÄ hip-clang++                  # Wrapper script
‚îú‚îÄ‚îÄ CMakeLists.txt               # HIP compiler integration
‚îî‚îÄ‚îÄ README.md                    # Usage guide

vortex_hip/tests/compiler/
‚îú‚îÄ‚îÄ test_simple.cpp              # Test cases
‚îú‚îÄ‚îÄ test_complex.cpp
‚îú‚îÄ‚îÄ test_structs.cpp
‚îî‚îÄ‚îÄ run_tests.sh                 # Test runner
```

### Files to Modify

```
llvm-project/clang/examples/CMakeLists.txt
  # Add: add_subdirectory(VortexHIPPlugin)

vortex_hip/runtime/CMakeLists.txt
  # Add compiler detection and integration

vortex/config.mk
  # Add VORTEX_HIP_PLUGIN variable
```

---

## API Reference

### Key Clang APIs

```cpp
// AST Context - type information
ASTContext::getTypeSize(QualType)        // Get type size in bits
ASTContext::getTypeAlign(QualType)       // Get type alignment in bits
ASTContext::getASTRecordLayout(RecordDecl) // Get struct layout

// Function Declaration
FunctionDecl::parameters()               // Get parameter list
FunctionDecl::hasAttr<CUDAGlobalAttr>() // Check for __global__

// Parameter Declaration
ParmVarDecl::getType()                  // Get parameter type
ParmVarDecl::getName()                  // Get parameter name

// Type Queries
QualType::isPointerType()               // Check if pointer
QualType::isIntegerType()               // Check if integer
QualType::isFloatingType()              // Check if float/double
QualType::isStructureOrClassType()      // Check if struct
```

---

## References

- **LLVM Documentation:** https://llvm.org/docs/
- **Clang Plugin Tutorial:** https://clang.llvm.org/docs/ClangPlugins.html
- **AST Matchers:** https://clang.llvm.org/docs/LibASTMatchers.html
- **Vortex LLVM:** https://github.com/vortexgpgpu/llvm
- **RISC-V ABI:** https://github.com/riscv-non-isa/riscv-elf-psabi-doc

---

## Status and Next Actions

**‚úÖ Completed:**
- Runtime metadata marshaling
- Manual metadata creation
- Test framework validation
- Python reference implementation
- **This design document**

**üîß Ready to Implement:**
- Clang plugin skeleton
- Basic kernel detection
- Type extraction
- Code generation

**‚è≠Ô∏è Next Step:**
Create `llvm-project/clang/examples/VortexHIPPlugin/VortexHIPPlugin.cpp` and begin implementation.

---

**Document Version:** 1.0
**Last Updated:** 2025-11-06
**Maintained By:** Vortex HIP Team
