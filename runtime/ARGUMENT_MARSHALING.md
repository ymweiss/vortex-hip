# HIP Argument Marshaling Implementation

## Overview

This document describes the argument marshaling implementation in the Vortex HIP runtime, which bridges HIP's array-of-pointers argument model with Vortex's struct-based argument model.

## The Problem

**HIP/CUDA API:**
```cpp
vectorAdd<<<grid, block>>>(d_a, d_b, d_c, N);
// Transformed by compiler to:
void** args = {&d_a, &d_b, &d_c, &N};
hipLaunchKernel(vectorAdd, grid, block, args, ...);
```

**Vortex API:**
```cpp
struct kernel_args {
    // Must be packed correctly
};
vx_start(device, kernel_binary, args_buffer);
```

## Solution: Metadata-Driven Marshaling

### 1. Metadata Structure

```c
typedef struct {
    size_t offset;        // Offset in argument buffer
    size_t size;          // Size in bytes
    size_t alignment;     // Required alignment
    int is_pointer;       // Non-zero if pointer type
} hipKernelArgumentMetadata;
```

### 2. Kernel Registration

The HIP compiler generates registration code with metadata:

```cpp
// Auto-generated by compiler
__attribute__((constructor))
static void register_vectorAdd() {
    static const hipKernelArgumentMetadata metadata[] = {
        {.offset = 0,  .size = 8, .alignment = 8, .is_pointer = 1},  // float* a
        {.offset = 8,  .size = 8, .alignment = 8, .is_pointer = 1},  // float* b
        {.offset = 16, .size = 8, .alignment = 8, .is_pointer = 1},  // float* c
        {.offset = 24, .size = 4, .alignment = 4, .is_pointer = 0}   // int n
    };

    __hipRegisterFunctionWithMetadata(
        &vectorAdd_handle,
        "vectorAdd",
        vectorAdd_binary,
        vectorAdd_binary_size,
        4,  // num args
        metadata
    );
}
```

### 3. Runtime Marshaling

When `hipLaunchKernel()` is called:

```cpp
hipError_t hipLaunchKernel(const void* func, dim3 grid, dim3 block,
                           void** args, ...) {
    // 1. Look up kernel metadata
    KernelInfo& kernel = g_kernel_registry[func];

    // 2. Create Vortex argument buffer
    std::vector<uint8_t> arg_buffer;

    // Add grid/block dimensions (Vortex convention)
    pack_grid_block_dims(arg_buffer, grid, block);

    // 3. Marshal arguments using metadata
    for (size_t i = 0; i < kernel.num_args; i++) {
        const ArgumentMetadata& meta = kernel.arg_metadata[i];

        // Ensure alignment
        size_t padding = calculate_padding(arg_buffer.size(), meta.alignment);
        arg_buffer.resize(arg_buffer.size() + padding);

        // Copy argument with correct size (not assuming 64-bit!)
        const uint8_t* src = (const uint8_t*)args[i];
        arg_buffer.insert(arg_buffer.end(), src, src + meta.size);
    }

    // 4. Upload and launch
    vx_upload_bytes(device, arg_buffer.data(), arg_buffer.size(), &args_buf);
    vx_start(device, kernel.binary, args_buf);
}
```

## Memory Layout Example

### Input: HIP Arguments

```
Kernel: vectorAdd(float* a, float* b, float* c, int n)

HIP receives:
args[0] = &d_a    (pointer to float*, value 0x100000)
args[1] = &d_b    (pointer to float*, value 0x200000)
args[2] = &d_c    (pointer to float*, value 0x300000)
args[3] = &n      (pointer to int, value 1024)
```

### Output: Vortex Argument Buffer

```
Byte Offset  | Size | Type        | Value           | Source
─────────────┼──────┼─────────────┼─────────────────┼────────────────
0-11         | 12B  | grid_dim    | [4, 1, 1]       | Runtime added
12-23        | 12B  | block_dim   | [256, 1, 1]     | Runtime added
24-31        | 8B   | shared_mem  | 0               | Runtime added
32-39        | 8B   | float* a    | 0x100000        | Metadata: offset=0, size=8
40-47        | 8B   | float* b    | 0x200000        | Metadata: offset=8, size=8
48-55        | 8B   | float* c    | 0x300000        | Metadata: offset=16, size=8
56-59        | 4B   | int n       | 1024            | Metadata: offset=24, size=4
60-63        | 4B   | padding     | 0               | Alignment
─────────────┴──────┴─────────────┴─────────────────┴────────────────
Total: 64 bytes
```

## Device-Side Access

The kernel receives the argument buffer and accesses it:

```cpp
// Device-side kernel wrapper (compiler-generated)
struct __vectorAdd_args {
    uint32_t grid_dim[3];   // Offset 0
    uint32_t block_dim[3];  // Offset 12
    uint64_t shared_mem;    // Offset 24
    float* arg0;            // Offset 32 (from metadata)
    float* arg1;            // Offset 40
    float* arg2;            // Offset 48
    int arg3;               // Offset 56
} __attribute__((packed));

int main() {
    __vectorAdd_args* args = (__vectorAdd_args*)csr_read(VX_CSR_MSCRATCH);

    // Spawn threads with kernel body
    vx_spawn_threads(1, args->grid_dim, args->block_dim,
                     (vx_kernel_func_cb)vectorAdd_body, args);
}
```

## Complex Example: Mixed Types

```cpp
__global__ void complexKernel(
    float* output,      // 8 bytes, align 8
    Vec3 position,      // 12 bytes, align 4 (struct by value!)
    int count,          // 4 bytes, align 4
    double* data        // 8 bytes, align 8
)
```

### Metadata

```cpp
static const hipKernelArgumentMetadata metadata[] = {
    {.offset = 0,  .size = 8,  .alignment = 8, .is_pointer = 1},  // float*
    {.offset = 8,  .size = 12, .alignment = 4, .is_pointer = 0},  // Vec3
    {.offset = 20, .size = 4,  .alignment = 4, .is_pointer = 0},  // int
    {.offset = 24, .size = 8,  .alignment = 8, .is_pointer = 1}   // double*
};
```

### Buffer Layout

```
Offset  | Size | Type        | Notes
────────┼──────┼─────────────┼─────────────────────
0-7     | 8B   | float*      | Pointer
8-19    | 12B  | Vec3        | Struct by value (x, y, z)
20-23   | 4B   | int         | Scalar
24-31   | 8B   | double*     | Pointer (aligned to 8)
```

Without metadata, the runtime would incorrectly assume all are 8 bytes!

## Implementation Files

### Public API
- **`include/vortex_hip_runtime.h`**
  - `hipKernelArgumentMetadata` - Public metadata structure
  - `__hipRegisterFunctionWithMetadata()` - Registration with metadata

### Implementation
- **`src/vortex_hip_runtime.cpp`**
  - `ArgumentMetadata` - Internal typedef
  - `VortexKernelInfo` - Extended with `arg_metadata` vector
  - `hipLaunchKernel()` - Metadata-based marshaling loop

### Examples
- **`examples/test_marshaling.cpp`** - Demonstrates registration and marshaling

## Key Features

### ✅ Correct Sizes
No more assuming all arguments are 64-bit. Each argument uses its actual size from metadata.

### ✅ Proper Alignment
Padding is calculated based on metadata alignment requirements, preventing GPU crashes.

### ✅ Type Awareness
Distinguishes between pointers and scalars (useful for future optimizations).

### ✅ Backwards Compatible
Falls back to 64-bit assumption if metadata is not provided.

### ✅ Zero Runtime Overhead
Metadata is read once at registration, marshaling is just memory copying.

## Compiler Requirements

For this system to work, the HIP compiler must:

1. **Analyze kernel signature** to determine argument types
2. **Calculate offsets and alignments** according to C ABI rules
3. **Generate metadata array** with accurate information
4. **Call registration function** at program startup

Example compiler output for `vectorAdd(float* a, float* b, float* c, int n)`:

```cpp
// 1. Declare metadata
static const hipKernelArgumentMetadata __vectorAdd_metadata[] = {
    {0, 8, 8, 1},   // a: pointer, 8 bytes, 8-byte aligned
    {8, 8, 8, 1},   // b: pointer, 8 bytes, 8-byte aligned
    {16, 8, 8, 1},  // c: pointer, 8 bytes, 8-byte aligned
    {24, 4, 4, 0}   // n: scalar, 4 bytes, 4-byte aligned
};

// 2. Register at startup
__attribute__((constructor))
static void __register_vectorAdd() {
    __hipRegisterFunctionWithMetadata(
        &__vectorAdd_handle,
        "vectorAdd",
        __vectorAdd_vxbin,
        __vectorAdd_vxbin_size,
        4,
        __vectorAdd_metadata
    );
}
```

## Testing

Build and run the test:

```bash
cd runtime/build
make
./examples/test_marshaling
```

Expected output shows:
- Kernel registration with metadata
- Argument layout calculation
- Expected buffer structure
- Benefits of metadata-driven marshaling

## Future Enhancements

1. **Metadata extraction from binary** - Parse DWARF/ELF debug info
2. **Validation** - Check args array matches metadata expectations
3. **Optimization** - Pre-calculate buffer layouts at registration time
4. **Error reporting** - Detailed messages for marshaling failures
5. **Profiling** - Track marshaling overhead

## Status

✅ **Implementation Complete**

- [x] Metadata structure defined
- [x] Registration function with metadata
- [x] Metadata-based marshaling in hipLaunchKernel
- [x] Backwards compatibility for non-metadata kernels
- [x] Test example demonstrating the system
- [x] Documentation

**Next Steps:**
- Integrate with HIP compiler to generate metadata
- Test with real Vortex kernels
- Validate on hardware

---

**Last Updated:** 2025-11-06
**Author:** Claude Code
**Status:** Ready for compiler integration
